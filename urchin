#!/usr/bin/ruby
# Copyright (c) 2010 Mark Somerville <mark@scottishclimbs.com>
# Released under the GNU General Public License (GPL) version 3.
# See COPYING.

begin
  $LOAD_PATH.delete "."
  require "optparse"
  require "strscan"
  require "fileutils"

  require "rbconfig"
  unless File.exists? "#{RbConfig::CONFIG["sitelibdir"]}/readline.rb"
    # Looks like rb-readline was not installed in site_ruby.
    require "rubygems"
  end
  begin
    require "rb-readline"
  rescue LoadError
    require "rubygems"
    require "readline"
  end

  begin
    require "termios"
  rescue LoadError
    # Looks like termios was not installed in site_ruby or we loaded the Gem
    # instead.
    require "rubygems"
    require "termios"
  end

  $LOAD_PATH << File.expand_path(File.dirname(__FILE__))
  require "lib/string"
  require "lib/readline"
  require "lib/completer"
  require "lib/history"
  require "lib/shell"
  require "lib/parser"
  require "lib/job_table"
  require "lib/job"
  require "lib/command"
  require "lib/os_process"
  require "lib/ruby_process"
  require "lib/builtin"
  require "lib/urchin_runtime_error"

  Dir.glob("#{File.dirname(__FILE__)}/{builtins,completion}/*.rb").each do |path|
    require path
  end

  require "environment"

  options = {}
  OptionParser.new do |opts|
    opts.banner = "Usage: urchin [options]"

    opts.on("-c", "--commands [COMMANDS]", "Run this command string using /bin/sh") do |command_string|
      options[:command_string] = command_string
    end

    opts.on("-h", "--help", "Show this message") do
      puts opts
      exit 0
    end

    opts.on("--version", "Show version") do
      puts `cd #{File.expand_path(File.dirname(__FILE__))}; git describe --always --dirty 2>/dev/null || echo "Can\'t find version information from Git."`
      exit 0
    end

  end.parse!

  # For compatibility with scripts that use `$SHELL -c "command"`.
  @shell = Urchin::Shell.new
  if options[:command_string]
    @shell.parse_and_run options[:command_string]
  else
    Readline.completion_proc = Urchin::Completer.new(ENV["PATH"], @shell).completion_proc
    @shell.run
  end
rescue Exception => exception
  if exception.class == SystemExit
    exit exception.status
  end
  if @shell
    @shell.history.cleanup
  end
  puts "Urchin exited.\n\n"
  STDERR.puts "  #{exception.class}: #{exception.message}"
  STDERR.puts "  "+exception.backtrace.join("\n  ")
  gets
end
